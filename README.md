# heuristic-contest

[AtCoder Heuristic Contest](https://atcoder.jp/contests/archive?ratedType=0&category=0&keyword=AtCoder+Heuristic+Contest) で以下のことを効率的に行うためのテンプレートです。解答に用いる言語が C++ であればこのテンプレートを使えます。

- テストケースを生成する。
- 求解するプログラムを一つのテストケースで実行し、得点と解の内容及びビジュアライズの結果を表示する。
- 求解するプログラムのデバッグを行う。
- 求解するプログラムを大量のテストケースで並列実行し、最低得点・最高得点・平均得点と最低(最高)得点を獲得したテストケースの名前を表示する。
- 求解するプログラムを一つのテストケースで実行し、求解途中の解のスナップショットを特定の時間 (デフォルトでは 10 ms) ごとに取得して点数の時間変化を折れ線グラフで表示する。また、解の時間変化を動画で表示する。

# 注意

1. 解をビジュアライズして表示する機能を使用するには [ffmpeg](http://ffmpeg.org/) のインストールが必要です。パッケージマネージャからインストールできるものをそのままインストールするのではなく、ソースコードをダウンロードして `--enable-librsvg, --enable-gpl, --enable-libx264` フラグを有効化してビルドしたものを用いる必要があります。
1. デバッガ上でプログラムを実行する機能を使用するには [GDB](https://www.gnu.org/software/gdb/) または [LLDB](https://lldb.llvm.org/) のインストールが必要です。LLDB を使用する場合は `makefile` の 15 行目の `DEBUGGER = gdb` の右辺を LLDB を起動するコマンド (`lldb` など) に書き換え、90 行目をコメントアウトして 91 行目のコメントアウトを解除してください。
1. Windows Subsystem for Linux を利用していない場合、または Windows Subsystem for Linux を利用していて Windows のローカルドライブをマウントしていない場合には `makefile` の 10 行目の `OPEN = ...` の右辺を、動画や画像のファイル名を引数として与えるとそれらをビューアーで開く機能を持つ別のコマンドに変更する必要があります。
1. C++ のソースファイルをコンパイルするコマンドを `clang++` に変更したい場合は 2 行目の `CXX = g++` を `CXX = clang++` に変更するなど、他にも設定の変更が必要な場合は `makefile` の編集を行ってください。

# 作業用リポジトリの作成

このリポジトリの fork や clone を行って問題を解くためにそのまま使用してもよいですが、問題を解く際にこのリポジトリに既に存在しているコミット履歴を参照する必要は無いので GitHub のテンプレート機能を利用して 1 つの問題に対して新しいリポジトリを 1 つ作成することをおすすめします(問題を解きながら、アルゴリズムの変更を行った場合などに変更内容や獲得した点数をコミットメッセージに記録していくようにするとよいかもしれません)。テンプレート機能を利用して新しいリポジトリを作成するには、[このリポジトリのページ](https://github.com/naskya/heuristic-contest) にある "Use this template" と書かれたボタンをクリックします。公開設定を public にすると書いた解答を push した時にその内容が公開されることに注意してください。コンテスト中に解答を公開するとルール違反となるので、コンテストが終了するまでは公開設定を private にしておくことを強く推奨します(終了後に公開設定を public に変更することもできます)。

![リポジトリの作成画面](https://naskya.net/share/github/naskya/heuristic-contest/readme_01.png)

リポジトリを作成したら、ローカルに clone するなどして使用します。

問題を解くのではなく、このテンプレートの内容そのものを編集して機能の追加やバグの修正などをしていただけるのであれば、このリポジトリを fork してください。Issue や Pull Request は歓迎します(必ず取り込まれるとは限りませんが)。

# 使い方

1. `visualizer` ディレクトリに AtCoder 公式で提供されているビジュアライザをそのまま入れます。`visualizer` ディレクトリ直下に `Cargo.toml` がある状態にしてください。
1. `make files=500 gen` を実行して、 `test/in` ディレクトリ内にテストケースを生成します。`files=500` の部分は生成する数の指定で、省略すると 500 個のテストケースが生成されます。このコマンドは毎回 `test/in` ディレクトリの内容を置き換えるので、テストケースの数が多すぎたり少なすぎたりした場合にはもう一度このコマンドを実行するとよいです。
1. 解答は `src/main.cpp` に書きます。
    - 必要最低限のライブラリしか include されていないので、include 文は必要に応じて追加してください。
      ```C++
      #include <bits/stdc++.h>
      using namespace std;
      ```
      をしたい人はしてもよいです。
    - 68 行目の `time_limit` の値を問題の実行時間制限に合わせて変更し(単位は ms)、134 行目の `threads` の値を使っている PC に搭載されている CPU のスレッド数(またはそれより少し小さい数)に変更してください。
    - 100 行目にある `struct result` が解答として出力する内容を表すようにコードを編集します。例えば [AHC001](https://atcoder.jp/contests/ahc001/tasks/ahc001_a) では出力するものが 4 つの数の配列なので
      ```C++
      struct result {
        std::vector<int> a, b, c, d;
      };
      ```
      などとします。
    - `struct result` のすぐ下にある `print` 関数を、解答を表す変数 `res` を受け取ってその内容を `os` に出力するように書き換えます。`std::cout` の代わりに `os` を使うのだと思っておけばよいです。[AHC001](https://atcoder.jp/contests/ahc001/tasks/ahc001_a) の例では
      ```C++
      void print(std::ostream& os, const result& res) {
        for (std::size_t i = 0; i < std::size(res.a); i++)
          os << res.a[i] << ' ' << res.b[i] << ' '
             << res.c[i] << ' ' << res.d[i] << '\n';
      }
      ```
      などとします。
    - `solve` 関数内の `// declare variables` と書いてある部分で入力する変数の宣言を行い、その下にあるラムダ式 `scan` の中に入力を `is` から読むコードを書きます。`std::cin` の代わりに `is` を使うのだと思っておけばよいです。[AHC001](https://atcoder.jp/contests/ahc001/tasks/ahc001_a) の例では
      ```C++
      // declare variables
      int n;
      std::vector<int> x, y, r;

      const auto scan = [&] {
        // read inputs
        is >> n;

        x.resize(n);
        y.resize(n);
        r.resize(n);

        for (int i = 0; i < n; i++)
          is >> x[i] >> y[i] >> r[i];
      };
      safe_invoke(scan);
      ```
      などとします。
    - `// initialize solution` と書いてある部分で解(新たに `result` 型の変数を宣言するのではなく `solve` 関数のパラメータにある `res` という変数を解として使ってください)の初期化を行い、`// improve solution` と書いてある部分で解を改善するようにします。
    - `solve` 関数内で標準出力に解を出力するコードを書く必要はありません。求解が終わると `print` 関数が呼ばれて解が出力されるようになっています。
    - このテンプレートはある程度改変して使っても構いませんが、`END_MAINLOOP` や `END_SOLVE_FUNC` を書く位置には気をつけてください。求解を複数のステップに分け、複数のループを回す場合には
      ```C++
        // 実行時間が制限時間の 1/3 になるまで処理 1 をする
        while (tm.frac<1, 3>()) {
          // 処理 1
          // ...
          END_MAINLOOP;
        }

        // 実行時間が制限時間の 2/3 になるまで処理 2 をする
        while (tm.frac<2, 3>()) {
          // 処理 2
          // ...
          END_MAINLOOP;
        }

        // 実行時間が制限時間になるまで処理 3 をする
        while (tm.good()) {
          // 処理 3
          // ...
          END_MAINLOOP;
        }

        END_SOLVE_FUNC;
      ```
      のように `END_MAINLOOP` を複数書くことになる場合があります。`END_SOLVE_FUNC` は常に `solve` 関数の末尾に 1 つだけ書いてください。途中解のスナップショットの取得は `END_MAINLOOP` や `END_SOLVE_FUNC` の行にいる時に行われるので、これらの行にいる時に `res` の内容は (0 点でもいいので) 解として正常な状態である必要があります。例えばこの行に到達しても `res` の内容が未初期化である場合には未初期化の変数へのアクセスが発生し未定義動作が起きます。
    - 求解のプログラムは並列で実行されるので、競合(一つの変数に複数のスレッドが同時に書き込みを行うなど)が発生しないように気をつけてください。
        - 例えば、以下のことは行ってよいです。
            - 関数内でローカル変数を宣言・使用する
            - グローバルに定数を宣言して読み取り専用の値として使用する
            - 内部で状態を保持しない関数 (競技プログラミングで書くような関数の多くはそうです) を作成して使用する
            - `static` 修飾された変数を持たないクラスを作成して使用する
        - 例えば、以下のことは行わないでください。どうしても行う必要がある場合は入力の読み込みのように `safe_invoke` 関数を通して行えばよいですが、テストを並列で実行する際にテスト間で同じ変数が共有されることになるので、プログラムの挙動が想定通りにならない可能性があります。
            - グローバルに変数を宣言し、その変数に書き込みを行う
            - `static` 修飾された変数を用いた関数やクラスを作成して、その変数に書き込みを行う
1. 解答を書いたら、今度は `utility/calc_score.cpp` に「標準入力からテストの入力と出力を順番に受け取り、スコアを標準出力に出力するプログラム」を書きます。
1. 以上の手順が完了したら、以下のコマンドを使用することができます。`case=0000` の部分はテストケース名で、好きに変えることができます。テストケースを指定しないと `test/in/0000.txt` が使用されます。
    - `make case=0000 normal`: 通常の実行を行い以下の内容を出力する
        - 点数
        - 解の内容
        - 解のビジュアライズ (1 枚の画像)
    - `make case=0000 debug`: デバッグ実行する
    - `make case=0000 debugger`: プログラムをデバッガを用いて実行する
        - プログラムは `main` 関数に入ってすぐに一時停止され、操作(実行を続ける・ステップ実行する・ブレークポイントを作るなど)を待つ状態になります。
    - `make case=0000 graph`: スコアの遷移のグラフを作成する
    - `make case=0000 mov`: スコアと解が遷移する様子を見られるグラフと動画を作成する
    - `make multi`: 全てのケースを並列で実行し以下の内容を出力する
        - 最低点
        - 最低点を出したテストケース名
        - 最高点
        - 最高点を出したテストケース名
        - 平均点

より詳しい内容は[このページ](https://naskya.net/post/0004/)に書いてあります。
