# 注意

1. 求解の途中の状態を動画として出力する機能を使用するには [ffmpeg](http://ffmpeg.org/) のインストールが必要です。パッケージマネージャからインストールできるものをそのままインストールするのではなく、ソースコードをダウンロードして `--enable-librsvg, --enable-gpl, --enable-libx264` フラグを有効化してビルドしたものを用いる必要があります。
1. デバッガを起動して実行を行う機能を使用するには [GDB](https://www.gnu.org/software/gdb/) または [LLDB](https://lldb.llvm.org/) のインストールが必要です。LLDB を使用する場合は `makefile` の 15 行目の `DEBUGGER = gdb` の右辺を LLDB を起動するコマンド (`lldb` など) に書き換え、90 行目をコメントアウトして 91 行目のコメントアウトを解除してください。
1. Windows Subsystem for Linux を利用していない場合、または Windows Subsystem for Linux の中で Windows のローカルドライブをマウントしていない場合には `makefile` の 10 行目の `OPEN = ...` の右辺を、動画や画像のファイル名を引数として与えるとそれらをビューアーで開く機能を持つ別のコマンドに変更する必要があります。他にも、C++ のソースファイルをコンパイルするコマンドを `clang++` に変更したい場合は 2 行目の `CXX = g++` を `CXX = clang++` に変更するなど、環境に応じた設定の変更が必要な場合は `makefile` の編集を行ってください。

# 使い方

0. このリポジトリの fork や clone を行って問題を解くためにそのまま使用してもよいですが、問題を解く際にこのリポジトリに既に存在しているコミット履歴を参照する必要は無いので GitHub のテンプレート機能を利用して 1 つの問題に対して新しいリポジトリを 1 つ作成することをおすすめします(アルゴリズムの変更を行った場合などに、したことや獲得した点数をコミットメッセージに記録していくようにするとよいかもしれません)。テンプレート機能を利用して新しいリポジトリを作成するには、[このリポジトリのページ](https://github.com/naskya/heuristic-contest) にある "Use this template" と書かれたボタンをクリックします。公開設定を public にすると書いた解答を push した時にその内容が公開されることに注意してください。コンテスト中は公開設定を private にしておくことをおすすめします(コンテスト終了後に公開設定を public に変更することもできます)。
![リポジトリの作成画面](https://naskya.net/share/github/naskya/heuristic-contest/readme_01.png)
リポジトリを作成したら、ローカルに clone するなどして使用します。
1. `visualizer` ディレクトリに AtCoder 公式で提供されているビジュアライザをそのまま入れます。`visualizer` ディレクトリ直下に `Cargo.toml` がある状態にしてください。
1. `make files=500 gen` を実行して、 `test/in` ディレクトリ内にテストケースを生成します。`files=500` の部分は生成する数の指定で、省略すると 500 個のテストケースが生成されます。このコマンドは毎回 `test/in` ディレクトリの内容を置き換えるので、テストケースの数が多すぎたり少なすぎたりした場合にはもう一度このコマンドを実行するとよいです。
1. 解答は `src/main.cpp` に書きます。
    - はじめに、63 行目の `time_limit` の値を問題の実行時間制限に合わせて変更し(単位は ms)、129 行目の `threads` の値を使っている PC に搭載されている CPU のスレッド数(またはそれより少し小さい数)に変更してください。
    - 95 行目にある `struct result` が解答として出力する内容を表すようにコードを編集します。例えば [AHC001](https://atcoder.jp/contests/ahc001/tasks/ahc001_a) では出力するものが 4 つの数の配列なので
      ```C++
      struct result {
        std::vector<int> a, b, c, d;
      };
      ```
      などとします。
    - `struct result` のすぐ下にある `print` 関数を、解答を表す変数 `res` を受け取ってその内容を `os` に出力するように書き換えます。`std::cout` の代わりに `os` を使うのだと思っておけばよいです。[AHC001](https://atcoder.jp/contests/ahc001/tasks/ahc001_a) の例では
      ```C++
      void print(std::ostream& os, const result& res) {
        for (std::size_t i = 0; i < std::size(res.a); i++)
          os << res.a[i] << ' ' << res.b[i] << ' '
             << res.c[i] << ' ' << res.d[i] << '\n';
      }
      ```
      などとします。
    - `solve` 関数内の `// declare variables` と書いてある部分で入力する変数の宣言を行い、その下にあるラムダ式 `scan` の中に入力を `is` から読むコードを書きます。`std::cin` の代わりに `is` を使うのだと思っておけばよいです。[AHC001](https://atcoder.jp/contests/ahc001/tasks/ahc001_a) の例では
      ```C++
      // declare variables
      int n;
      std::vector<int> x, y, r;

      const auto scan = [&] {
        // read inputs
        is >> n;

        x.resize(n);
        y.resize(n);
        r.resize(n);

        for (int i = 0; i < n; i++)
          is >> x[i] >> y[i] >> r[i];
      };
      safe_invoke(scan);
      ```
      などとします。
    - あとは `// initialize solution` と書いてある部分で解(`res` という変数です)の初期化を行い、`// improve solution` と書いてある部分で解を改善するようにします。最後に標準出力に解を出力するように書く必要はありません。求解が終わると `print` 関数が呼ばれて解が出力されるようになっています。テンプレートはある程度改変して使っても構いませんが、`END_MAINLOOP` や `END_SOLVE_FUNC` を書く位置などには気をつけてください。
    - 求解のプログラムは並列で実行されるので、競合(一つの変数に複数のスレッドが同時に書き込みを行うなど)が発生しないように気をつけてください。
        - 例えば、以下のことは行ってよいです。
            - 関数内でローカル変数を宣言する
            - グローバルに定数を宣言して読み取り専用の値として使用する
            - 内部で状態を保持しない関数を作成して使用する
            - `static` 修飾された変数を持たないクラスを作成して使用する
        - 例えば、以下のことは行わないでください。どうしても行う必要がある場合は入力の読み込みのように `safe_invoke` 関数を通して行えばよいですが、テストケースを並列で実行する際に別のテストケース間で同じ変数が共有されることになるので、プログラムの挙動が想定通りにならない可能性があります。
            - グローバルに変数を宣言し、その変数に書き込みを行う
            - `static` 修飾された変数を用いた関数やクラスを作成して、その変数に書き込みを行う
1. 解答を書いたら、今度は `utility/calc_score.cpp` に「標準入力からテストの入力と出力を順番に受け取り、スコアを標準出力に出力するプログラム」を書きます。
1. 以上の手順が完了したら、以下のコマンドを使用することができます。`case=0000` の部分はテストケース名で、好きに変えることができます。テストケースを指定しないと `test/in/0000.txt` が使用されます。
    - `make case=0000 normal`: 通常の実行を行い以下の内容を出力する
        - 点数
        - 解の内容
        - 解のビジュアライズ (1 枚の画像)
    - `make case=0000 debug`: デバッグ実行する
    - `make case=0000 debugger`: プログラムをデバッガを用いて実行する
        - プログラムは `main` 関数に入ってすぐに一時停止され、操作(実行を続ける・ステップ実行する・ブレークポイントを作るなど)を待つ状態になります。
    - `make case=0000 graph`: スコアの遷移のグラフを作成する
    - `make case=0000 mov`: スコアと解が遷移する様子を見られるグラフと動画を作成する
    - `make multi`: 全てのケースを並列で実行し以下の内容を出力する
        - 最低点
        - 最低点を出したテストケース名
        - 最高点
        - 最高点を出したテストケース名
        - 平均点

より詳しい内容は[このページ](https://naskya.net/post/0004/)に書いてあります。
